% Find the eigenvalues and eigenfunctions of the bilinear map measuring the
% inner product of the exact component between two vector fields.

%% Initialize Matlab
clear
clc

%% User Inputs
% Data loading parameters
subject = "H5983";
side = "Left";

% Plot parameters
plot_invert = true;

% Reference and moving surfaces:
% 1 = LTC, 2 = LLL, 3 = LUL
mov_surf = 2; % Transformations applied to this surface
ref_surf = 3; % Used to identify fissure interface

% Directories and file patterns
mesh_dir = 'Y:\Documents\BioMOST_Research\Lung_FE\FEBio\Meshes_v3\';
mesh_pattern = '${SUBJECT}_${SIDE}Lung_Lobes_Mesh_v3.mat';

%% Load subject's mesh and identify fissure
% Load mesh data
mesh_name = replace( mesh_pattern, ["${SUBJECT}","${SIDE}"], [subject,side] );
mesh_file = fullfile( mesh_dir, mesh_name );
load( mesh_file, "NodeArray", "ElementArray", "nID", "eID" );

% Get the reference and moving surfaces
EA_ref = ElementArray( eID == ref_surf, : ); 
FA_ref = FESurface( EA_ref );
EA_mov = ElementArray( eID == mov_surf, : );
FA_mov = FESurface( EA_mov );

% Identify the fissure surface on the moving lobe
[ FID_fissure, NID_fissure ] = ContactInterface( FA_mov, NodeArray, FA_ref, NodeArray );
FA_fissure_global = FA_mov( FID_fissure, : );

% Get a local and global mesh numbering for the fissure
NA_fissure = NodeArray( NID_fissure, : );
[ ~, ~, FA_fissure_local ] = unique( FA_fissure_global );
FA_fissure_local = reshape( FA_fissure_local, [], 3 );

% Get important geometric info about fissure surface
DEC = AssembleDEC( FA_fissure_local, NA_fissure );
ip1 = DEC.hs1; % Inner product on 1-forms

%% Generate Input Transformations
VF_array = cell(3,1);
options = struct();

% Generate translation vector fields and put in cell array
options.t_type = 'translation';
options.t_vel = [1,0,0];
VF_array{1} = GenerateVelocityField( NA_fissure, options );
options.t_vel = [0,1,0];
VF_array{2} = GenerateVelocityField( NA_fissure, options );
options.t_vel = [0,0,1];
VF_array{3} = GenerateVelocityField( NA_fissure, options );

% Generate rotation vector fields about the "naive" centroid
% options.t_type = 'rotation';
% options.origin = mean( NodeArray, 1 );
% options.ang_vel = [1,0,0];
% VF_array{4} = GenerateVelocityField( NA_fissure, options );
% options.ang_vel = [0,1,0];
% VF_array{5} = GenerateVelocityField( NA_fissure, options );
% options.ang_vel = [0,0,1];
% VF_array{6} = GenerateVelocityField( NA_fissure, options );

num_vfs = numel(VF_array);

%% Perform HHD on the 1-form generated by each vector field then normalize the vector fields
% HHD
HHD_array = cell(size(VF_array));
for i = 1:numel(VF_array)
    HHD_array{i} = HHD_GradientRecon( FA_fissure_local, NA_fissure, VF_array{i} );
end

% Normalize so that input 1-forms have magnitude 1 
% WRONG!!!
% Normalize to whatever metric the inputs are orthogonal in
% In this case that would be the 3D transformations
mag_omega = nan( num_vfs, 1 );
VF_norm = cell(size(VF_array));
for i = 1:num_vfs
    mag_omega(i) = sqrt( HHD_array{i}.omega1F' * ip1 * HHD_array{i}.omega1F );
    mag_omega(i) = vecnorm( VF_array{i}(1,:), 2, 2 );
    VF_norm{i} = VF_array{i} / mag_omega(i);
end

%% Compute the Covariance Matrix and find its Eigenvalues
C = nan(num_vfs);
for j = 1:num_vfs
    for i = 1:num_vfs
        % Renormalize exact component (allowed by linearity)
        da_i = HHD_array{i}.diff_alpha1F / mag_omega(i);
        da_j = HHD_array{j}.diff_alpha1F / mag_omega(j);
        
        % Compute covariance matrix in normalized components
        C(i,j) = da_i' * ip1 * da_j;
    end
end

% Get the eigenvectors (V) and eigenvalues (D) of the covariance matrix
[V,D] = eig(C);
lambda = diag(D);
[lambda, sort_ind] = sort(lambda,'ascend');
V = V(:,sort_ind);

% Get the eigenvector fields
VF_eigen = cell(size(VF_array));
for j = 1:num_vfs
    VF_eigen{j} = zeros( size(NA_fissure) );
    for i = 1:num_vfs
        VF_eigen{j} =  VF_eigen{j} + V(i,j) * VF_norm{i};
    end
end

%% Visualize Eigenvalues
options = struct();
options.spacing = 15;
options.LineWidth = 1.5;
n_srows = ceil( num_vfs/3 );
n_scols = min( num_vfs, 3 );

% figure()
% sgtitle('Input Vector Fields') 
% for i = 1:num_vfs
%     subplot( n_srows, n_scols, i )
%     hold on
%     quiver3( NA_fissure(:,1), NA_fissure(:,2), NA_fissure(:,3), VF_array{i}(:,1), VF_array{i}(:,2), VF_array{i}(:,3) )
%     trimesh( FA_fissure_local, NA_fissure(:,1), NA_fissure(:,2), NA_fissure(:,3), ...
%              'FaceColor', [0.80,0.80,0.80], 'EdgeColor', [0,0,0], 'FaceAlpha', 1 )
%     daspect([1,1,1])
%     xlabel('X')
%     ylabel('Y')
%     zlabel('Z')
%     if plot_invert
%     set(gca, 'Zdir', 'reverse')
%     set(gca, 'Ydir', 'reverse')
%     end
%     hold off
% end
% 
% figure()
% sgtitle('Input Vector Field Streamlines') 
% for i = 1:num_vfs
%     subplot( n_srows, n_scols, i )
%     PlotTriSurfStreamline( FA_fissure_local, NA_fissure, VF_array{i}, options )
%     daspect([1,1,1])
%     xlabel('X')
%     ylabel('Y')
%     zlabel('Z')
%     if plot_invert
%     set(gca, 'Zdir', 'reverse')
%     set(gca, 'Ydir', 'reverse')
%     end
% end
% 
% figure()
% sgtitle('Eigen Vector Fields') 
% for i = 1:num_vfs
%     subplot( n_srows, n_scols, i )
%     hold on
%     quiver3( NA_fissure(:,1), NA_fissure(:,2), NA_fissure(:,3), VF_eigen{i}(:,1), VF_eigen{i}(:,2), VF_eigen{i}(:,3) )
%     trimesh( FA_fissure_local, NA_fissure(:,1), NA_fissure(:,2), NA_fissure(:,3), ...
%              'FaceColor', [0.80,0.80,0.80], 'EdgeColor', [0,0,0], 'FaceAlpha', 1 )
%     daspect([1,1,1])
%     title( sprintf( 'Eigenvector Value = %f', sqrt(lambda(i)) ) )
%     xlabel('X')
%     ylabel('Y')
%     zlabel('Z')
%     if plot_invert
%     set(gca, 'Zdir', 'reverse')
%     set(gca, 'Ydir', 'reverse')
%     end
%     hold off
% end

figure()
sgtitle('Eigen Vector Field Streamlines') 
for i = 1:num_vfs
    subplot( n_srows, n_scols, i )
    PlotTriSurfStreamline( FA_fissure_local, NA_fissure, VF_eigen{i}, options )
    title( sprintf( 'Eigenvector Value = %f', sqrt(lambda(i)) ) )
    daspect([1,1,1])
    xlabel('X')
    ylabel('Y')
    zlabel('Z')
    if plot_invert
    set(gca, 'Zdir', 'reverse')
    set(gca, 'Ydir', 'reverse')
    end
end
